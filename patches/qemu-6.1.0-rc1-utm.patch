From 178ae37602a7a3e7be8814a104b12f7421bdacc2 Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 18:08:15 -0700
Subject: [PATCH 1/2] tcti: fix build after latest TCG changes

---
 accel/tcg/cpu-exec.c              | 5 +++++
 tcg/aarch64-tcti/tcg-target.c.inc | 6 ++----
 tcg/aarch64-tcti/tcg-target.h     | 6 +-----
 3 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index 462556a712..74e7833d8e 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -164,6 +164,11 @@ uint32_t curr_cflags(CPUState *cpu)
     } else if (qemu_loglevel_mask(CPU_LOG_TB_NOCHAIN)) {
         cflags |= CF_NO_GOTO_TB;
     }
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+    // GOTO_PTR is too complex to emit a simple gadget for.
+    // We'll let C handle it, since the overhead is similar.
+    cflags |= CF_NO_GOTO_TB;
+#endif
 
     return cflags;
 }
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index d7bb67a921..5a77d2f96d 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -1214,11 +1214,9 @@ static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
 }
 
 /* Test if a constant matches the constraint. */
-static int tcg_target_const_match(tcg_target_long val, TCGType type,
-                                  const TCGArgConstraint *arg_ct)
+static bool tcg_target_const_match(int64_t val, TCGType type, int ct)
 {
-    /* No need to return 0 or 1, 0 or != 0 is good enough. */
-    return arg_ct->ct & TCG_CT_CONST;
+    return ct & TCG_CT_CONST;
 }
 
 static void tcg_target_init(TCGContext *s)
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index fa2ae5c40a..7eb3bb1c3d 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -50,6 +50,7 @@
 
 #define TCG_TARGET_INSN_UNIT_SIZE        1
 #define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+#define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)
 
 // We're an interpreted target; even if we're JIT-compiling to our interpreter's
 // weird psuedo-native bytecode. We'll indicate that we're intepreted.
@@ -142,11 +143,6 @@
 #define TCG_TARGET_HAS_ctz_i64          0
 #define TCG_TARGET_HAS_ctpop_i64        0
 
-
-// GOTO_PTR is too complex to emit a simple gadget for.
-// We'll let C handle it, since the overhead is similar.
-#define TCG_TARGET_HAS_goto_ptr         0
-
 // We don't have a simple gadget for this, since we're always assuming softmmu.
 #define TCG_TARGET_HAS_qemu_st8_i32     0
 
-- 
2.28.0

From 8dfd81c4d180084437c39f0de47afa7357f43e9d Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 21:02:02 -0700
Subject: [PATCH 2/2] virtio-ramfb: enable GL if supported

---
 hw/display/virtio-ramfb.c | 49 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 46 insertions(+), 3 deletions(-)

diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
index d08bb90a14..19a050ae5d 100644
--- a/hw/display/virtio-ramfb.c
+++ b/hw/display/virtio-ramfb.c
@@ -1,4 +1,5 @@
 #include "qemu/osdep.h"
+#include "sysemu/sysemu.h"
 #include "hw/pci/pci.h"
 #include "ui/console.h"
 #include "hw/qdev-properties.h"
@@ -27,6 +28,18 @@ struct VirtIORAMFBBaseClass {
     DeviceReset parent_reset;
 };
 
+static int virtio_ramfb_get_flags(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->get_flags) {
+        return g->hw_ops->get_flags(g);
+    } else {
+        return 0;
+    }
+}
+
 static void virtio_ramfb_invalidate_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -37,6 +50,16 @@ static void virtio_ramfb_invalidate_display(void *opaque)
     }
 }
 
+static void virtio_ramfb_text_update(void *opaque, console_ch_t *chardata)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->text_update) {
+        g->hw_ops->text_update(g, chardata);
+    }
+}
+
 static void virtio_ramfb_update_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -70,11 +93,24 @@ static void virtio_ramfb_gl_block(void *opaque, bool block)
     }
 }
 
+static void virtio_ramfb_gl_flushed(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_flushed) {
+        g->hw_ops->gl_flushed(g);
+    }
+}
+
 static const GraphicHwOps virtio_ramfb_ops = {
+    .get_flags = virtio_ramfb_get_flags,
     .invalidate = virtio_ramfb_invalidate_display,
     .gfx_update = virtio_ramfb_update_display,
+    .text_update = virtio_ramfb_text_update,
     .ui_info = virtio_ramfb_ui_info,
     .gl_block = virtio_ramfb_gl_block,
+    .gl_flushed = virtio_ramfb_gl_flushed,
 };
 
 static const VMStateDescription vmstate_virtio_ramfb = {
@@ -161,15 +197,22 @@ struct VirtIORAMFB {
     VirtIORAMFBBase parent_obj;
 
     VirtIOGPU     vdev;
+    VirtIOGPUGL   vdevgl;
 };
 
 static void virtio_ramfb_inst_initfn(Object *obj)
 {
     VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
 
-    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-                                TYPE_VIRTIO_GPU);
-    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    if (display_opengl) {
+        virtio_instance_init_common(obj, &dev->vdevgl, sizeof(dev->vdevgl),
+                                    TYPE_VIRTIO_GPU_GL);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdevgl);
+    } else {
+        virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                    TYPE_VIRTIO_GPU);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    }
 }
 
 static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
-- 
2.28.0

