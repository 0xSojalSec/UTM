From f71ace26c5a885d74512c86f0ef2e83a0408468e Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 18:08:15 -0700
Subject: [PATCH 1/3] tcti: fix build after latest TCG changes

---
 accel/tcg/tcg-accel-ops.c         | 5 +++++
 include/tcg/tcg-opc.h             | 4 ++++
 tcg/aarch64-tcti/tcg-target.c.inc | 6 ++----
 tcg/aarch64-tcti/tcg-target.h     | 6 +-----
 tcg/tcg.c                         | 8 +++++++-
 5 files changed, 19 insertions(+), 10 deletions(-)

diff --git a/accel/tcg/tcg-accel-ops.c b/accel/tcg/tcg-accel-ops.c
index 1a8e8390bd..bfc4105bcf 100644
--- a/accel/tcg/tcg-accel-ops.c
+++ b/accel/tcg/tcg-accel-ops.c
@@ -45,6 +45,11 @@ void tcg_cpu_init_cflags(CPUState *cpu, bool parallel)
     uint32_t cflags = cpu->cluster_index << CF_CLUSTER_SHIFT;
     cflags |= parallel ? CF_PARALLEL : 0;
     cflags |= icount_enabled() ? CF_USE_ICOUNT : 0;
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+    // GOTO_PTR is too complex to emit a simple gadget for.
+    // We'll let C handle it, since the overhead is similar.
+    cflags |= CF_NO_GOTO_PTR;
+#endif
     cpu->tcg_cflags = cflags;
 }
 
diff --git a/include/tcg/tcg-opc.h b/include/tcg/tcg-opc.h
index 675873e200..7db7899c86 100644
--- a/include/tcg/tcg-opc.h
+++ b/include/tcg/tcg-opc.h
@@ -194,7 +194,11 @@ DEF(insn_start, 0, 0, TLADDR_ARGS * TARGET_INSN_START_WORDS,
     TCG_OPF_NOT_PRESENT)
 DEF(exit_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
 DEF(goto_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT)
+#else
 DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#endif
 
 DEF(plugin_cb_start, 0, 0, 3, TCG_OPF_NOT_PRESENT)
 DEF(plugin_cb_end, 0, 0, 0, TCG_OPF_NOT_PRESENT)
diff --git a/tcg/aarch64-tcti/tcg-target.c.inc b/tcg/aarch64-tcti/tcg-target.c.inc
index d7bb67a921..5a77d2f96d 100644
--- a/tcg/aarch64-tcti/tcg-target.c.inc
+++ b/tcg/aarch64-tcti/tcg-target.c.inc
@@ -1214,11 +1214,9 @@ static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
 }
 
 /* Test if a constant matches the constraint. */
-static int tcg_target_const_match(tcg_target_long val, TCGType type,
-                                  const TCGArgConstraint *arg_ct)
+static bool tcg_target_const_match(int64_t val, TCGType type, int ct)
 {
-    /* No need to return 0 or 1, 0 or != 0 is good enough. */
-    return arg_ct->ct & TCG_CT_CONST;
+    return ct & TCG_CT_CONST;
 }
 
 static void tcg_target_init(TCGContext *s)
diff --git a/tcg/aarch64-tcti/tcg-target.h b/tcg/aarch64-tcti/tcg-target.h
index fa2ae5c40a..7eb3bb1c3d 100644
--- a/tcg/aarch64-tcti/tcg-target.h
+++ b/tcg/aarch64-tcti/tcg-target.h
@@ -50,6 +50,7 @@
 
 #define TCG_TARGET_INSN_UNIT_SIZE        1
 #define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+#define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)
 
 // We're an interpreted target; even if we're JIT-compiling to our interpreter's
 // weird psuedo-native bytecode. We'll indicate that we're intepreted.
@@ -142,11 +143,6 @@
 #define TCG_TARGET_HAS_ctz_i64          0
 #define TCG_TARGET_HAS_ctpop_i64        0
 
-
-// GOTO_PTR is too complex to emit a simple gadget for.
-// We'll let C handle it, since the overhead is similar.
-#define TCG_TARGET_HAS_goto_ptr         0
-
 // We don't have a simple gadget for this, since we're always assuming softmmu.
 #define TCG_TARGET_HAS_qemu_st8_i32     0
 
diff --git a/tcg/tcg.c b/tcg/tcg.c
index b6031417d6..4b6c5ba5e3 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -1175,13 +1175,19 @@ bool tcg_op_supported(TCGOpcode op)
     case INDEX_op_insn_start:
     case INDEX_op_exit_tb:
     case INDEX_op_goto_tb:
-    case INDEX_op_goto_ptr:
     case INDEX_op_qemu_ld_i32:
     case INDEX_op_qemu_st_i32:
     case INDEX_op_qemu_ld_i64:
     case INDEX_op_qemu_st_i64:
         return true;
 
+    case INDEX_op_goto_ptr:
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+        return false;
+#else
+        return true;
+#endif
+
     case INDEX_op_qemu_st8_i32:
         return TCG_TARGET_HAS_qemu_st8_i32;
 
-- 
2.28.0

From 8dfd81c4d180084437c39f0de47afa7357f43e9d Mon Sep 17 00:00:00 2001
From: osy <50960678+osy@users.noreply.github.com>
Date: Mon, 2 Aug 2021 21:02:02 -0700
Subject: [PATCH 2/2] virtio-ramfb: enable GL if supported

---
 hw/display/virtio-ramfb.c | 49 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 46 insertions(+), 3 deletions(-)

diff --git a/hw/display/virtio-ramfb.c b/hw/display/virtio-ramfb.c
index d08bb90a14..19a050ae5d 100644
--- a/hw/display/virtio-ramfb.c
+++ b/hw/display/virtio-ramfb.c
@@ -1,4 +1,5 @@
 #include "qemu/osdep.h"
+#include "sysemu/sysemu.h"
 #include "hw/pci/pci.h"
 #include "ui/console.h"
 #include "hw/qdev-properties.h"
@@ -27,6 +28,18 @@ struct VirtIORAMFBBaseClass {
     DeviceReset parent_reset;
 };
 
+static int virtio_ramfb_get_flags(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->get_flags) {
+        return g->hw_ops->get_flags(g);
+    } else {
+        return 0;
+    }
+}
+
 static void virtio_ramfb_invalidate_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -37,6 +50,16 @@ static void virtio_ramfb_invalidate_display(void *opaque)
     }
 }
 
+static void virtio_ramfb_text_update(void *opaque, console_ch_t *chardata)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->text_update) {
+        g->hw_ops->text_update(g, chardata);
+    }
+}
+
 static void virtio_ramfb_update_display(void *opaque)
 {
     VirtIORAMFBBase *vramfb = opaque;
@@ -70,11 +93,24 @@ static void virtio_ramfb_gl_block(void *opaque, bool block)
     }
 }
 
+static void virtio_ramfb_gl_flushed(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_flushed) {
+        g->hw_ops->gl_flushed(g);
+    }
+}
+
 static const GraphicHwOps virtio_ramfb_ops = {
+    .get_flags = virtio_ramfb_get_flags,
     .invalidate = virtio_ramfb_invalidate_display,
     .gfx_update = virtio_ramfb_update_display,
+    .text_update = virtio_ramfb_text_update,
     .ui_info = virtio_ramfb_ui_info,
     .gl_block = virtio_ramfb_gl_block,
+    .gl_flushed = virtio_ramfb_gl_flushed,
 };
 
 static const VMStateDescription vmstate_virtio_ramfb = {
@@ -161,15 +197,22 @@ struct VirtIORAMFB {
     VirtIORAMFBBase parent_obj;
 
     VirtIOGPU     vdev;
+    VirtIOGPUGL   vdevgl;
 };
 
 static void virtio_ramfb_inst_initfn(Object *obj)
 {
     VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
 
-    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
-                                TYPE_VIRTIO_GPU);
-    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    if (display_opengl) {
+        virtio_instance_init_common(obj, &dev->vdevgl, sizeof(dev->vdevgl),
+                                    TYPE_VIRTIO_GPU_GL);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdevgl);
+    } else {
+        virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                    TYPE_VIRTIO_GPU);
+        VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+    }
 }
 
 static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
-- 
2.28.0

